#!/usr/bin/env python3

import gnupg
from pathlib import Path
from getpass import getpass
from subprocess import Popen, PIPE
import json
import argparse
import sys
import pyperclip
import pickle
import yaml
import pyotp
import os
import time
import tempfile

class bwCLI:
    def __init__(self):
        self.bwsess = None

    def error(self, subcmd, rc, out, err, session):
        # if a session is required for the failed command check the session
        if session:
            if not self.unlocked():
                print("Run 'den -r' there are no valid sessions.")
                os._exit(1)
        print("The command 'bw {}' exited with code '{}'".format(subcmd, rc))
        print("---- stdout ----\n{}\n---- stderr ----\n{}\n".format(out, err))
        os._exit(1)

    def unlocked(self):
        rc, out, err = self._call(['status', '--raw'], True)
        if rc != 0:
            # set session to false to avoid loop
            self.error('status', rc, out, err, False)
        lines = [l for l in out.splitlines() if l.strip()]
        json_lines = []
        for line in lines:
            try: json_lines.append(json.loads(line))
            except: pass
        assert(len(json_lines) == 1)
        assert('status' in json_lines[0])
        status = json_lines[0]['status'].lower()
        assert(status in ('locked', 'unlocked'))
        if status == 'unlocked':
            return True
        return False

    def call(self, args, session=True):
        rc, out, err = self._call(args, session)
        if rc != 0:
            self.error(args[0], rc, out, err, session)
        else:
            return out

    def _call(self, args, session):
        print(args,session)
        # if session is need and not set try to get session
        if session and self.bwsess.session_token == '':
            self.bwsess.decrypt_session()
        cmd = ['bw']
        cmd.extend(args)
        if session:
            cmd.extend(['--session', self.bwsess.session_token])
        # The auto password prompt cant be disabled :(
        # was wanting to use a in memory file but gave up
        # https://stackoverflow.com/questions/18421757/live-output-from-subprocess-command
        # https://docs.pyfilesystem.org/en/latest/reference/memoryfs.html
        # neiter work need fileno() for the object
        with tempfile.NamedTemporaryFile() as tmp:
            writer = open(tmp.name, 'wb')
            reader = open(tmp.name, 'rb')
            bw_proc = Popen(cmd, shell=False, stdin=PIPE, stdout=PIPE, stderr=writer)
            while bw_proc.poll() is None:
                time.sleep(0.1)
                err = reader.read().decode('utf-8')
                if '? Master password:' in err:
                    bw_proc.stdin.write(b'\n')
                    try: bw_proc.stdin.flush()
                    except BrokenPipeError as e:
                        pass
        out = bw_proc.stdout.read().decode('utf-8')
        return (bw_proc.returncode, out, err)

    def unlock(self, passphrase):
        return self._call(['unlock', passphrase, '--raw'], False)

    def lock(self):
        return self.call(['lock'], False)

    def sync(self):
        return self.call(['sync'])

    def get(self, item_id):
        return self.call(['get', 'item', item_id, '--raw'])

    def list(self, obj):
        return self.call(['list', obj])


class gpgHelper:
    def __init__(self, config):
        self.config = config
        self.gpg = gnupg.GPG(gnupghome=str(self.config.gpg_home), use_agent=True)

        keys_pub = self.gpg.list_keys().key_map
        key = keys_pub.get(self.config.fingerprint)
        if not key:
            sys.exit("Could not find fingerprint in public keyring: '{}'".format(self.config.fingerprint))
        keys_priv = self.gpg.list_keys().key_map
        key = keys_priv.get(self.config.fingerprint)
        if not key:
            sys.exit("Could not find fingerprint in secrets keyring: '{}'".format(self.config.fingerprint))

    def decrypt_file(self, file_path):
        self.verify_asc_file(file_path)
        with open(file_path, 'rb') as f:
            result = str(self.gpg.decrypt_file(f))
        return result

    def encrypt_to_file(self, content, file_path):
        if not content:
            sys.exit("Nothing was given to encrypt to '{}'".format(file_path))
        self.gpg.encrypt(content, self.config.fingerprint, output=file_path)
        file_path.chmod(self.config.perms)
        self.verify_asc_file(file_path)

    def verify_asc_file(self, file_path):
        assert(file_path.suffix == '.asc')
        if not file_path.is_file():
            sys.exit("No encrypted file at: '{}'".format(file_path))
        assert(file_path.stat().st_size > 0)
        assert(file_path.stat().st_mode == self.config.perms)
        with open(file_path, 'r') as f:
            content = f.read()
        content = content.strip().splitlines()
        assert('-----BEGIN PGP MESSAGE-----' in content)
        assert('-----END PGP MESSAGE-----' in content)

class denConf:
    def __init__(self):
        self.encrypted_session = Path.home() / '.bw-session.asc'
        # stat.filemode(0o100600) -> '-rw-------'
        self.perms = 0o100600
        self.fingerprint = 'C9CB0C945B583DD3E65DDC376B5C20C74C63902A'
        self.gpg_home = Path.home() / '.gnupg'

        self.cache_obj_fields = {'id', 'name', 'folderId', 'organizationId', 'collectionIds', 'password', 'totp', 'login'}
        self.cache_obj_fields_redact = {'password', 'totp','login'}
        self.cache_obj_types = {'items', 'folders', 'collections', 'organizations'}

        self.cache_path = Path.home() / '.bw-cache.asc'

        # The pickle helps speedup dev around the cache
        self.pickle_path = Path('cache.pickle')
        self.redacted_pickle_path = Path('redacted-cache.pickle')
        self.pickle = False
        # self.pickle = True

class bwSession:
    def __init__(self, config):
        self.config = config
        self.bwcli = bwCLI()
        self.gpg = gpgHelper(self.config)
        self.session_token = ''
        self.bwcli.bwsess = self

    def new_session(self):
        self.bwcli.lock()
        rc = 1
        while (rc != 0):
            passphrase = getpass()
            rc, out, err = self.bwcli.unlock(passphrase)
        self.session_token = out
        if not self.bwcli.unlocked():
            sys.exit("Session failed to unlock")
        self.gpg.encrypt_to_file(self.session_token, self.config.encrypted_session)

    def decrypt_session(self):
        self.session_token = self.gpg.decrypt_file(self.config.encrypted_session)
        if not self.session_token:
            sys.exit("Failed to decrypt session or empty file. Try this command\n  gpg --decrypt '{}'".format(self.config.encrypted_session))


class bwHelper:
    def __init__(self):
        self.config = denConf()
        self.bwsess = bwSession(self.config)
        self.gpg = self.bwsess.gpg
        self.bwcli = self.bwsess.bwcli
        self.cache_dict = {}
        for obj_type in self.config.cache_obj_types:
            self.cache_dict[obj_type] = {}

    def refresh(self):
        if self.config.pickle and self.config.pickle_path.is_file():
            self.bwsess.decrypt_session()
            with open(self.config.pickle_path, 'rb') as f:
                self.cache_dict = pickle.load(f)
        else:
            self.bwsess.new_session()
            out = self.bwcli.sync()
            for obj in list(self.cache_dict.keys()):
                out = self.bwcli.list(obj)
                try: self.cache_dict[obj] = json.loads(out)
                except: sys.exit("Failed to parse json from '{}'.".format(obj))
            if self.config.pickle:
                with open(self.config.pickle_path, 'wb') as f:
                    pickle.dump(self.cache_dict, f)
            else:
                if self.config.pickle_path.is_file():
                    self.config.pickle_path.unlink()
        self.cache_redact()
        if self.config.pickle:
            with open(self.config.redacted_pickle_path, 'wb') as f:
                pickle.dump(self.cache_dict, f)
        else:
            if self.config.redacted_pickle_path.is_file():
                self.config.redacted_pickle_path.unlink()
        self.gpg.encrypt_to_file(json.dumps(self.cache_dict), self.config.cache_path)

    #TODO: hmm this does not seem ideal...
    def cache_redact(self):
        for obj_type in list(self.cache_dict.keys()):
            for obj_idx in range(len(self.cache_dict[obj_type])):
                for k in list(self.cache_dict[obj_type][obj_idx].keys()):
                    if k not in self.config.cache_obj_fields:
                        del self.cache_dict[obj_type][obj_idx][k]
                        continue
                    # redact creds to bool
                    if k in self.config.cache_obj_fields_redact:
                        if k == 'login':
                            self.cache_dict[obj_type][obj_idx]['password'] = bool(self.cache_dict[obj_type][obj_idx][k]['password'])
                            self.cache_dict[obj_type][obj_idx]['totp'] = bool(self.cache_dict[obj_type][obj_idx][k]['totp'])
                            del self.cache_dict[obj_type][obj_idx][k]
                        else:
                            self.cache_dict[obj_type][obj_idx][k] = bool(self.cache_dict[obj_type][obj_idx][k])

    def decrypt_cache(self):
        self.cache_dict = self.gpg.decrypt_file(self.config.cache_path)
        if not self.cache_dict:
            sys.exit("Failed to decrypt cache or empty file. Try this command\n  gpg --decrypt '{}'".format(self.config.cache_path))
        try: self.cache_dict = json.loads(self.cache_dict)
        except: sys.exit("Failed to parse json from '{}'.".format(self.config.cache_path))
        assert(self.config.cache_obj_types == set(self.cache_dict.keys()))

    def completion(self, obj_type):
        assert(obj_type in self.config.cache_obj_types | {'all'})
        if obj_type == 'all':
            return json.dumps(self.cache_dict)
        names = set()
        for obj in self.cache_dict[obj_type]:
            assert('name' in obj)
            names.add(obj['name'])
        return '\n'.join(sorted(names))


def cli_parse():
    parser = argparse.ArgumentParser(description='Simplified interface for copying Passwords and TOTPs from Bitwarden')
    group = parser.add_mutually_exclusive_group()
    parser.add_argument('item',
                        nargs='?',
                        type=str,
                        help='item name/id',
                        metavar='I')
    parser.add_argument('-f',
                        '--folder',
                        type=str,
                        help='folder name',
                        metavar='F')
    parser.add_argument('-o',
                        '--organization',
                        type=str,
                        help='organization name',
                        metavar='O')
    parser.add_argument('-c',
                        '--collection',
                        type=str,
                        help='collection name',
                        metavar='C')
    parser.add_argument('-n',
                        '--no-clip',
                        action='store_true',
                        help='do not use clipboard')
    group.add_argument ('-a',
                        '--all-fields',
                        action='store_true',
                        help='return all fields of [I]')
    group.add_argument ('-p',
                        '--password',
                        action='store_true',
                        help='return password of [I]')
    group.add_argument ('-t',
                        '--totp',
                        action='store_true',
                        help='return totp of [I]')
    group.add_argument ('-s',
                        '--session',
                        action='store_true',
                        help='return session token')
    group.add_argument ('-r',
                        '--refresh',
                        action='store_true',
                        help='lock then unlock bitwarden, sync bitwarden, update cache')
    group.add_argument ('-z',
                        '--completion',
                        type=str,
                        help="list cached 'item', 'folder', 'collection', or 'organization' names for shell completion",
                        metavar='Z')
    parser.add_argument('-y',
                        '--yml-conf',
                        type=str,
                        help='path to yml conf file, default is {}'.format('test'))

    # parser.print_help(sys.stderr)

    if not len(sys.argv) > 1:
        parser.error("No arguments were passed")

    # get args and values as dict
    args = vars(parser.parse_args())

    if (args['folder'] or args['collection'] or args['organization']) and args['item'] is None:
        parser.error("need to pass 'I' if using '-f', '-c', and/or '-o'")

    bwhelp = bwHelper()

    if args['yml_conf']:
        pass

    if args['refresh']:
        bwhelp.refresh()
        if args['no_clip']:
            print(bwhelp.bwsess.session_token)
        else:
            pyperclip.copy(bwhelp.bwsess.session_token)
        return

    # Ensure there is a session before doing anything else
    bwhelp.bwsess.decrypt_session()
    if not bwhelp.bwsess.session_token:
        sys.exit("Create a session before preceeding.")

    bwhelp.decrypt_cache()

    if args['completion']:
        print(bwhelp.completion(args['completion']))
        return

    if args['session']:
        bwhelp.bwsess.decrypt_session()
        if args['no_clip']:
            print(bwhelp.bwsess.session_token)
        else:
            pyperclip.copy(bwhelp.bwsess.session_token)
        return

    if args['all_fields'] or args['password'] or args['totp']:
        if args['item'] is None:
            parser.error("need to pass 'S'")

    if args['all_fields']:
        for i in bwhelp.cache_dict['items']:
            if args['item'] == i['name']:
                out = bwhelp.bwcli.get(i['id'])
                print(out)

    if args['password']:
        for i in bwhelp.cache_dict['items']:
            if args['item'] == i['name']:
                if i['password']:
                    out = bwhelp.bwcli.get(i['id'])
                    print(json.loads(out)['login']['password'])


    return args


cli_parse()

