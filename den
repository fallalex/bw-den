#!/usr/bin/env python3

# bw unlock --raw
# pip3 install python-gnupg

import gnupg
from pathlib import Path
from getpass import getpass
from subprocess import Popen, PIPE
import json
import argparse
import sys
import pyperclip

import yaml
import pyotp

class bwCLI:
    def __init__(self):
        pass

    def call(self, args):
        bw_proc = Popen(args, shell=False, stdout=PIPE, stderr=PIPE)
        stdout, stderr = [s.decode('utf-8') for s in bw_proc.communicate()]
        return (bw_proc.returncode, stdout, stderr)

    def unlock(self, passphrase):
        return self.call(['bw', 'unlock', passphrase, '--raw'])

    def lock(self):
        return self.call(['bw', 'lock', '--raw'])

    def status(self, session):
        return self.call(['bw', 'status', '--raw', '--session', session])

    def get(self, item_id):
        return self.call(['bw', 'get', 'item', item_id])

    def list(self, obj):
        assert(obj in ('items', 'folders', 'collections', 'organizations'))
        return self.call(['bw', 'list', obj])

    # An item can be in one, none, or any of these: folder, organization, collection
    # Items can only be in one folder, organization, and collection.
    # A collection can only exist in an organization and only one.
    # Item names can be shared even when sharing the same folder, organization, and colleciton.
    # Item ids are the only way to uniquly identify an item.
    # This makes getting items annoying...

class gpgHelper:
    def __init__(self):
        # stat.filemode(0o100600) -> '-rw-------'
        self.perms = 0o100600
        self.fingerprint = 'C9CB0C945B583DD3E65DDC376B5C20C74C63902A'
        self.gpg_home = Path.home() / '.gnupg'
        self.gpg = gnupg.GPG(gnupghome=str(self.gpg_home), use_agent=True)

        keys_pub = self.gpg.list_keys().key_map
        key = keys_pub.get(self.fingerprint)
        if not key:
            sys.exit("Could not find fingerprint in public keyring: '{}'".format(self.fingerprint))
        keys_priv = self.gpg.list_keys().key_map
        key = keys_priv.get(self.fingerprint)
        if not key:
            sys.exit("Could not find fingerprint in secrets keyring: '{}'".format(self.fingerprint))

    def decrypt_file(self, file_path):
        self.verify_asc_file(file_path)
        with open(file_path, 'rb') as f:
            result = self.gpg.decrypt_file(f)
        return str(result)

    def encrypt_to_file(self, content, file_path):
        if not content:
            sys.exit("Nothing was given to encrypt to '{}'".format(file_path))
        self.gpg.encrypt(content, self.fingerprint, output=file_path)
        file_path.chmod(self.perms)
        self.verify_asc_file(file_path)

    def verify_asc_file(self, file_path):
        assert(file_path.suffix == '.asc')
        if not file_path.is_file():
            sys.exit("No encrypted file at: '{}'".format(file_path))
        assert(file_path.stat().st_size > 0)
        assert(file_path.stat().st_mode == self.perms)
        with open(file_path, 'r') as f:
            content = f.read()
        content = content.strip().splitlines()
        assert('-----BEGIN PGP MESSAGE-----' in content)
        assert('-----END PGP MESSAGE-----' in content)

class bwSession:
    def __init__(self, gpg_helper):
        self.bwcli = bwCLI()
        self.gpg = gpg_helper
        self.encrypted_session = Path.home() / '.bw-session.asc'
        self.session = ''

    def new_session(self):
        rc, out, err = self.bwcli.lock()
        if rc != 0:
            sys.exit("Failed to lock bitwarden: {} {}".format(out, err))
        rc = 1
        while (rc != 0):
            passphrase = getpass()
            rc, out, err = self.bwcli.unlock(passphrase)
        self.session = out
        if not self.session_unlocked():
            sys.exit("Session failed to unlock")
        self.gpg.encrypt_to_file(self.session, self.encrypted_session)

    def decrypt_session(self):
        self.session = self.gpg.decrypt_file(self.encrypted_session)
        if not self.session:
            # TODO: this error seems miss leading could be an empty file
            sys.exit("failed to decrypt session try this command\n  gpg --decrypt '{}'".format(self.encrypted_session))

    def session_unlocked(self):
        rc, out, err = self.bwcli.status(self.session)
        if rc != 0:
            sys.exit("'status' command failed. returncode: '{}' | stdout: '{}' | stderr: '{}'".format(rc, out, err))
        lines = [l for l in out.splitlines() if l.strip()]
        json_lines = []
        for line in lines:
            try: json_lines.append(json.loads(line))
            except: pass
        assert(len(json_lines) == 1)
        assert('status' in json_lines[0])
        status = json_lines[0]['status'].lower()
        assert(status in ('locked', 'unlocked'))
        if status == 'unlocked':
            return True
        return False

class bwHelper:
    def __init__(self):
        pass

    #TODO: get specific item
    #TODO: parse all items
    #TODO: encrypt to cache
    #TODO: decrypt cache
    #TODO: -z command option
    #TODO: sync bitwarden / refresh cache on new session


def cli_parse():
    parser = argparse.ArgumentParser(description='Simplified interface for copying Passwords and TOTPs from Bitwarden')
    group = parser.add_mutually_exclusive_group()
    parser.add_argument('item',
                        nargs='?',
                        type=str,
                        help='item name/id',
                        metavar='I')
    parser.add_argument('-f',
                        '--folder',
                        type=str,
                        help='folder name',
                        metavar='F')
    parser.add_argument('-o',
                        '--organization',
                        type=str,
                        help='organization name',
                        metavar='O')
    parser.add_argument('-c',
                        '--collection',
                        type=str,
                        help='collection name',
                        metavar='C')
    parser.add_argument('-n',
                        '--no-clip',
                        action='store_true',
                        help='do not use clipboard')
    group.add_argument ('-a',
                        '--all-fields',
                        action='store_true',
                        help='return all fields of [I]')
    group.add_argument ('-p',
                        '--password',
                        action='store_true',
                        help='return password of [I]')
    group.add_argument ('-t',
                        '--totp',
                        action='store_true',
                        help='return totp of [I]')
    group.add_argument ('-s',
                        '--session',
                        action='store_true',
                        help='return session token')
    group.add_argument ('-r',
                        '--refresh',
                        action='store_true',
                        help='lock then unlock bitwarden, sync bitwarden, update cache')
    #TODO: could try to do a fancy completion script that narrows the results based on current arg params
    group.add_argument ('-z',
                        '--completion',
                        type=str,
                        help="list cached 'item', 'folder', 'collection', or 'organization' names for shell completion",
                        metavar='Z')
    parser.add_argument('-y',
                        '--yml-conf',
                        type=str,
                        help='path to yml conf file, default is {}'.format('test'))

    # parser.print_help(sys.stderr)

    if not len(sys.argv) > 1:
        parser.error("No arguments were passed")

    # get args and values as dict
    args = vars(parser.parse_args())

    if (args['folder'] or args['collection'] or args['organization']) and args['item'] is None:
        parser.error("need to pass 'I' if using '-f', '-c', and/or '-o'")

    gpghelp = gpgHelper()
    bwsess = bwSession(gpghelp)

    if args['yml_conf']:
        # parse conf file
        pass

    if args['completion']:
        return

    if args['refresh']:
        bwsess.new_session()
        if args['no_clip']:
            print(bwsess.session)
        else:
            pyperclip.copy(bwsess.session)
        return

    if args['session']:
        bwsess.decrypt_session()
        if args['no_clip']:
            print(bwsess.session)
        else:
            pyperclip.copy(bwsess.session)
        return

    if args['all_fields'] or args['password'] or args['totp']:
        if args['item'] is None:
            parser.error("need to pass 'S'")

    return args


cli_parse()

