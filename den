#!/usr/bin/env python3

# bw unlock --raw
# pip3 install python-gnupg

import gnupg
from pathlib import Path
from getpass import getpass
from subprocess import Popen, PIPE
import json
import argparse
import sys
import pyperclip
import pickle

import yaml
import pyotp

# avoid multiple bwcli calls they are really slow
# fine for new session, cache gen, sync

class bwCLI:
    #TODO: do more error handling here so only return stdout
    def __init__(self):
        self.bwsess = None

    def call(self, args):
        bw_proc = Popen(args, shell=False, stdout=PIPE, stderr=PIPE)
        stdout, stderr = [s.decode('utf-8') for s in bw_proc.communicate()]
        return (bw_proc.returncode, stdout, stderr)
        #TODO: check if unlocked unless unlock

    def unlock(self, passphrase):
        return self.call(['bw', 'unlock', passphrase, '--raw'])

    def lock(self):
        return self.call(['bw', 'lock', '--raw'])

    def status(self):
        return self.call(['bw', 'status', '--raw', '--session', self.bwsess.session_token])

    def sync(self):
        return self.call(['bw', 'sync', '--session', self.bwsess.session_token])

    def get(self, item_id):
        return self.call(['bw', 'get', 'item', item_id, '--raw', '--session', self.bwsess.session_token])

    def list(self, obj):
        return self.call(['bw', 'list', obj, '--session', self.bwsess.session_token])

    # An item can be in one, none, or any of these: folder, organization, collection
    # Items can only be in one folder, organization, and collection.
    # A collection can only exist in an organization and only one.
    # Item names can be shared even when sharing the same folder, organization, and colleciton.
    # Item ids are the only way to uniquly identify an item.
    # This makes getting items annoying...

class gpgHelper:
    def __init__(self):
        # stat.filemode(0o100600) -> '-rw-------'
        self.perms = 0o100600
        self.fingerprint = 'C9CB0C945B583DD3E65DDC376B5C20C74C63902A'
        self.gpg_home = Path.home() / '.gnupg'
        self.gpg = gnupg.GPG(gnupghome=str(self.gpg_home), use_agent=True)

        keys_pub = self.gpg.list_keys().key_map
        key = keys_pub.get(self.fingerprint)
        if not key:
            sys.exit("Could not find fingerprint in public keyring: '{}'".format(self.fingerprint))
        keys_priv = self.gpg.list_keys().key_map
        key = keys_priv.get(self.fingerprint)
        if not key:
            sys.exit("Could not find fingerprint in secrets keyring: '{}'".format(self.fingerprint))

    def decrypt_file(self, file_path):
        self.verify_asc_file(file_path)
        with open(file_path, 'rb') as f:
            result = str(self.gpg.decrypt_file(f))
        return result

    def encrypt_to_file(self, content, file_path):
        if not content:
            sys.exit("Nothing was given to encrypt to '{}'".format(file_path))
        self.gpg.encrypt(content, self.fingerprint, output=file_path)
        file_path.chmod(self.perms)
        self.verify_asc_file(file_path)

    def verify_asc_file(self, file_path):
        assert(file_path.suffix == '.asc')
        if not file_path.is_file():
            sys.exit("No encrypted file at: '{}'".format(file_path))
        assert(file_path.stat().st_size > 0)
        assert(file_path.stat().st_mode == self.perms)
        with open(file_path, 'r') as f:
            content = f.read()
        content = content.strip().splitlines()
        assert('-----BEGIN PGP MESSAGE-----' in content)
        assert('-----END PGP MESSAGE-----' in content)

class bwSession:
    def __init__(self):
        self.bwcli = bwCLI()
        self.gpg = gpgHelper()
        self.encrypted_session = Path.home() / '.bw-session.asc'
        self.session_token = ''
        self.bwcli.bwsess = self

    def new_session(self):
        rc, out, err = self.bwcli.lock()
        if rc != 0:
            sys.exit("Failed to lock bitwarden: {} {}".format(out, err))
        rc = 1
        while (rc != 0):
            passphrase = getpass()
            rc, out, err = self.bwcli.unlock(passphrase)
        self.session_token = out
        if not self.unlocked():
            sys.exit("Session failed to unlock")
        self.gpg.encrypt_to_file(self.session_token, self.encrypted_session)

    def decrypt_session(self):
        self.session_token = self.gpg.decrypt_file(self.encrypted_session)
        if not self.session_token:
            sys.exit("Failed to decrypt session or empty file. Try this command\n  gpg --decrypt '{}'".format(self.encrypted_session))

    def unlocked(self):
        if self.session_token == '':
            self.decrypt_session()
        rc, out, err = self.bwcli.status()
        if rc != 0:
            sys.exit("'status' command failed. returncode: '{}' | stdout: '{}' | stderr: '{}'".format(rc, out, err))
        lines = [l for l in out.splitlines() if l.strip()]
        json_lines = []
        for line in lines:
            try: json_lines.append(json.loads(line))
            except: pass
        assert(len(json_lines) == 1)
        assert('status' in json_lines[0])
        status = json_lines[0]['status'].lower()
        assert(status in ('locked', 'unlocked'))
        if status == 'unlocked':
            return True
        return False

class bwHelper:
    def __init__(self):
        self.bwsess = bwSession()
        self.gpg = self.bwsess.gpg
        self.bwcli = self.bwsess.bwcli
        self.cache_obj_fields = {'id', 'name', 'folderId', 'organizationId', 'collectionIds', 'password', 'totp'}
        self.cache_obj_fields_redact = {'password', 'totp'}
        self.cache_obj_types = {'items', 'folders', 'collections', 'organizations'}
        self.cache_dict = {}
        for obj_type in self.cache_obj_types:
            self.cache_dict[obj_type] = {}
        self.cache_path = Path.home() / '.bw-cache.asc'

    def refresh(self):
        self.bwsess.new_session()
        rc, out, err = self.bwcli.sync()
        if rc != 0: sys.exit("Failed to sync.")
        # self.bwsess.decrypt_session()
        for obj in list(self.cache_dict.keys()):
            rc, out, err = self.bwcli.list(obj)
            if rc != 0: sys.exit("Failed to get list of '{}'.".format(obj))
            try: self.cache_dict[obj] = json.loads(out)
            except: sys.exit("Failed to parse json from '{}'.".format(obj))

        # with open('cache.pickle', 'rb') as f:
        #     self.cache_dict = pickle.load(f)

        self.cache_redact()
        self.gpg.encrypt_to_file(json.dumps(self.cache_dict), self.cache_path)

    #TODO: hmm this does not seem ideal...
    def cache_redact(self):
        for obj_type in list(self.cache_dict.keys()):
            for obj_idx in range(len(self.cache_dict[obj_type])):
                for k in list(self.cache_dict[obj_type][obj_idx].keys()):
                    if k not in self.cache_obj_fields:
                        del self.cache_dict[obj_type][obj_idx][k]
                        continue
                    # redact creds to bool
                    if k in self.cache_obj_fields_redact:
                        self.cache_dict[obj_type][obj_idx][k] = bool(self.cache_dict[obj_type][obj_idx][k])
                    #TODO: the password/totp are in the login dict need to pull them out

    def decrypt_cache(self):
        self.cache_dict = self.gpg.decrypt_file(self.cache_path)
        if not self.cache_dict:
            sys.exit("Failed to decrypt cache or empty file. Try this command\n  gpg --decrypt '{}'".format(self.cache_path))
        try: self.cache_dict = json.loads(self.cache_dict)
        except: sys.exit("Failed to parse json from '{}'.".format(self.cache_path))
        assert(self.cache_obj_types == set(self.cache_dict.keys()))

    def completion(self, obj_type):
        assert(obj_type in self.cache_obj_types | {'all'})
        if obj_type == 'all':
            return json.dumps(self.cache_dict)
        names = set()
        for obj in self.cache_dict[obj_type]:
            assert('name' in obj)
            names.add(obj['name'])
        return '\n'.join(sorted(names))


def cli_parse():
    parser = argparse.ArgumentParser(description='Simplified interface for copying Passwords and TOTPs from Bitwarden')
    group = parser.add_mutually_exclusive_group()
    parser.add_argument('item',
                        nargs='?',
                        type=str,
                        help='item name/id',
                        metavar='I')
    parser.add_argument('-f',
                        '--folder',
                        type=str,
                        help='folder name',
                        metavar='F')
    parser.add_argument('-o',
                        '--organization',
                        type=str,
                        help='organization name',
                        metavar='O')
    parser.add_argument('-c',
                        '--collection',
                        type=str,
                        help='collection name',
                        metavar='C')
    parser.add_argument('-n',
                        '--no-clip',
                        action='store_true',
                        help='do not use clipboard')
    group.add_argument ('-a',
                        '--all-fields',
                        action='store_true',
                        help='return all fields of [I]')
    group.add_argument ('-p',
                        '--password',
                        action='store_true',
                        help='return password of [I]')
    group.add_argument ('-t',
                        '--totp',
                        action='store_true',
                        help='return totp of [I]')
    group.add_argument ('-s',
                        '--session',
                        action='store_true',
                        help='return session token')
    group.add_argument ('-r',
                        '--refresh',
                        action='store_true',
                        help='lock then unlock bitwarden, sync bitwarden, update cache')
    group.add_argument ('-z',
                        '--completion',
                        type=str,
                        help="list cached 'item', 'folder', 'collection', or 'organization' names for shell completion",
                        metavar='Z')
    parser.add_argument('-y',
                        '--yml-conf',
                        type=str,
                        help='path to yml conf file, default is {}'.format('test'))

    # parser.print_help(sys.stderr)

    if not len(sys.argv) > 1:
        parser.error("No arguments were passed")

    # get args and values as dict
    args = vars(parser.parse_args())

    if (args['folder'] or args['collection'] or args['organization']) and args['item'] is None:
        parser.error("need to pass 'I' if using '-f', '-c', and/or '-o'")

    bwhelp = bwHelper()

    if args['yml_conf']:
        pass

    if args['refresh']:
        bwhelp.refresh()
        if args['no_clip']:
            print(bwhelp.bwsess.session_token)
        else:
            pyperclip.copy(bwhelp.bwsess.session_token)
        return

    # Ensure there is a session before doing anything else
    bwhelp.bwsess.decrypt_session()
    if not bwhelp.bwsess.session_token:
        sys.exit("Create a session before preceeding.")

    bwhelp.decrypt_cache()

    if args['completion']:
        print(bwhelp.completion(args['completion']))
        return

    if args['session']:
        bwhelp.bwsess.decrypt_session()
        if args['no_clip']:
            print(bwhelp.bwsess.session_token)
        else:
            pyperclip.copy(bwhelp.bwsess.session_token)
        return

    if args['all_fields'] or args['password'] or args['totp']:
        if args['item'] is None:
            parser.error("need to pass 'S'")

    if args['all_fields']:
        for i in bwhelp.cache_dict['items']:
            if args['item'] == i['name']:
                rc, out, err = bwhelp.bwcli.get(i['id'])
                if rc == 0:
                    print(out)

    if args['password']:
        for i in bwhelp.cache_dict['items']:
            if args['item'] == i['name']:
                if i['password']:
                    rc, out, err = bwhelp.bwcli.get(i['id'])
                    if rc == 0:
                        print(json.loads(out)['password'])


    return args


cli_parse()

